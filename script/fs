#!/usr/bin/env ruby

require 'fusefs'
require 'rubygems'
require 'couchrest'
require 'json'

# specify the database name here
DB_NAME = "nashi-01-development"

# couch fs will be mounted here
MOUNT_DIR = File.expand_path(File.join(File.dirname(__FILE__), '../app'))

# initialize couchrest database mapper
DB = CouchRest.database("http://127.0.0.1:5984/#{DB_NAME}")


# Quilt mixes CouchDB Design Documents into the filesystem provided by FuseFS::MetaDir.
#
# Directory Structure:
# /
#   ApplictionName
#     _rev
#     views
#       view_name
#         map.js
#         reduce.js
class Quilt < FuseFS::FuseDir
  def contents(path)
    base, *rest = scan_path(path)
    if base.nil?
      list_design_documents
    elsif rest.empty?
      ["views", "_rev"]
    elsif rest == ["views"]
      list_views(base)
    elsif rest.size == 2 && rest.first == "views"
      ["map.js", "reduce.js"]
    else
      []
    end
  end

  def file?(path)
    base, *rest = scan_path(path)
    # /Site/_rev
    # /Site/views/by_name/map.js
    # /Site/views/by_name/reduce.js
    rest == ["_rev"] ||
      rest.size == 3 && rest[0] == "views" && ["map.js", "reduce.js"].include?(rest.last)
  end

  def directory?(path)
    base, *rest = scan_path(path)
    # /Site
    # /Site/views
    # /Site/views/by_name
    rest.empty? || rest == ["views"] || (rest.size == 2 && rest.first == "views")
  end

  def executable?(path)
    return false if file?(path)
  end

  def read_file(path)
    return unless file?(path)
    parts = scan_path(path)
    read_content_for parts
  end

  def write_to(path, str)
    return unless file?(path)
    parts = scan_path(path)
    write_content_to parts, str
    true
  end

  private

  def list_design_documents
    docs = DB.documents :startkey => "_design/", :endkey => "_design/_", :include_docs => true
    docs.is_a?(Hash) ? docs["rows"].map { |doc| design_document_name(doc["id"]) }.sort : []
  end

  def list_views(name)
    doc = get_design_document(name)
    doc["views"].keys.sort
  end

  def read_content_for(parts)
    name = parts.shift
    result = get_design_document(name)
    parts.each do |part|
      p = part.sub(/\.js\z/, "")
      result = result[p]
    end
    result
  end

  def write_content_to(parts, str)
    puts parts.inspect
    puts str
  end

  def get_design_document(name)
    DB.get "_design/#{name}"
  end

  def design_document_name(id)
    id.split("/").last
  end
end

class CouchDir < FuseFS::MetaDir
  def initialize(*args)
    @quilt = Quilt.new
    super
  end

  def file?(path)
    @quilt.file?(path) || super
  end

  def directory?(path)
    @quilt.directory?(path) || super
  end

  def executable?(path)
    @quilt.executable?(path).nil? ? super : false
  end

  def contents(path)
    @quilt.contents(path) + (super || [])
  end

  def read_file(path)
    @quilt.read_file(path) || super
  end

  def can_write?(path)
    true
  end

  def write_to(path, str)
    @quilt.write_to(path, str) || super
  end
end


# main Quilt starts here

# create mount dir unless exists
Dir.mkdir(MOUNT_DIR) unless File.directory?(MOUNT_DIR)

# init couch dir
couchdir = CouchDir.new

FuseFS.set_root(couchdir)
FuseFS.mount_under MOUNT_DIR

trap("INT") do
  puts "ancelling..."
  FuseFS.unmount
  sleep 0.1
  FuseFS.exit
  puts "Bye."
end

puts "Quilt is running on #{MOUNT_DIR}"
FuseFS.run
